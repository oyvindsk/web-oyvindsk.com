
---
Title: 2 easy to make Golang bugs and how to avoid them
Author: Øyvind Skaar
Description: Whatever
Date: 2016-05-11 12h
Path: 2-bugs-and-how-to-avoid
---

<!-- Todo: Fiks linker så de åpnes i ny tab -->

    <article>

        <header>
            <h1>2 easy to make Golang bugs and how to avoid them</h1>
            <span>Last updated 11th of May 2016</span>
        </header>

        <img src="https://blog.golang.org/gopher/usergroups.png" />
        <h2></h2>

        <p>
            This post is about two of the few real bugs I've made while writing Go. Not entierly sure what I mean by "real bugs", but I guess it's something like: "Not just typos" and "took a while to fully understand".

            Although these are explained several places already, I have tried to be it a little more thorough.
        </p>

        <h1>Bug 1</h1>
        <p>
            This fault is easy to make in some situations. Look at the code bellow and try to figure out why Example B fails. Every code snipet has a link in the header to the same code snippet in the Go Playground.
            (All links open in this window).
        </p>

        <figure class="file"><figcaption><a href="https://play.golang.org/p/NJhdSw-sSC">https://play.golang.org/p/NJhdSw-sSC</a></figcaption><code><pre>

package main

import (
	"fmt"
	"time"
)

func main() {

	// A
	fmt.Println("Example A - Count to 2, This works :) ")
	for a := 0; a < 3; a++ {
		fmt.Println("a is:", a)
	}

	// B
	fmt.Println("\n\nExample B - Count to 2, concurrently.")
	fmt.Println("This does not work :( ")
	for b := 0; b < 3; b++ {
		go func() {
			fmt.Println("b is:", b)
		}()
	}

	// we sleep to let the go functions finish before the program quits
	time.Sleep(2 * time.Second) 
}
        </pre></code></figure>

        <p>
            Running the above code prints:
        </p>


        <figure class="shell"><code><pre>
Example A - Count to 2, This works :) 
a is: 0
a is: 1
a is: 2


Example B - Count to 2, concurrently.
This does not work :( 
b is: 3
b is: 3
b is: 3
        </pre></code></figure>

        <p>
            Huh? 3, 3, 3? Where's zero and one? And wasn't it suppose to stop at two? 
            Bah! We can't even count to 3, what's going on? Two things:
        </p>
        <h2>Closures</h2>
        <p>
            Firstly, when we print variable 'b' in Example B what are we refering to? It's inside of a function, and ther's no variable 'b' inside this function body. If you did this in a normal function you would get a nice little error from the compiler complaining that there's no 'b'.
            This does not happen here. The function we have in Example B, 'func(){..}',  is not a normal function. It's in the middle of another one and it does not have a name. These types of functions are often call <i>function literals</i> or <i>anonymous functions</i>. I like "anonymous functions". An anonymous function can "see" variables from the function it's inside (enclosed in). That means that in our example it can access variable 'b'. 

        <h2>Variable reuse</h2>
        <p>
            Our anonymous function can access variable 'b', but it's the same variable 'b', accessed 3 time in the loop. It's declared once before the loop starts to run. It then changes value from 1 to 1 to 2 and finally to 3.
            Then the loop stops since 3 is not less than 3.
        </p>

        <h2>Go routines runs out of order</h2>
        <p>
            With our 'go func()..' statement we start a new go routine. They run concurrently, which means is does not run one after the other in an orderly fashion. 
            They could, or they could all run at the same time (in parralell). Or maybe the "last one" runs first and then the "first one" and the "second one" runs last, or maybe.. Think you get the point; it's unpredictable.
            Well this is kind of the point of using Go routines in the first place. We want to be able to run many things at once. In this example it does not make a lot of sense, but imagine if you will that the printing took 10 seconds. Or we did something else that took 10 seconds. In that case Example A would take 30 seconds to complete and Example B would only take 10 seconds. Win! 
        </p>
        <p>
            We can think of the go statement as "run this code in the background at some point". It could run right away, or it could run later. Thinking like this it becomes more apparent why Example B fails. 
            It's verry possible, likely even, that the loop finishes before the first 'fmt.Println("b is:", b)' ever runs. So the loops runs, increasing 'b' to 3 and then stoppping. <em>Then</em> the go routines run and print variabale b. They all look at the same variable b, the one declared at the start of the loop. They never got their own copy. At this point 'b' is 3, and they all print 3.
        </p>







        <h1>Fixing</h1>
        <p>
            There are several ways to change your code and fix this bug. I've listed the 3 I could think of at this time, with the last one probably being the most "idiomatic" go.
        </p>

        <p>
            Each of these examples should print something like this if you run them. Note that the numbers can be out of order, since the go routines can run in any possible order, or all at once.
        </p>
        <figure class="shell"><code><pre>
Fix 2 for Example B
dd is: 1
dd is: 0
dd is: 2
        </pre></code></figure>


        <h2>Fix 1</h2>
        <p>One easy way of fixing this is to change the anonymous function to a normal function call. Normal functions and function call do not behave in the same way when it comes to referring to variables "outside" itself.
            When you call a normal function the arguments are copied, every time you call it. Therefore this works as you would expect:</p>
        <figure class="file"><figcaption><a href="https://play.golang.org/p/RuUUVeH1ZG">https://play.golang.org/p/RuUUVeH1ZG</a></figcaption><code><pre>


package main

import (
	"fmt"
	"time"
)

func main() {

	// Fix 1
	fmt.Println("\n\nFix 1 for Example B")
	for c := 0; c < 3; c++ {
		// same code as earlier,
		// but no longer in an anonymous function:
		go print(c)

		// The value of c is copied when we call print()
		//   so it's no longer refering to the same variable.

		// This copying happens before the code
		//   in print() acutally runs
	}

	time.Sleep(2 * time.Second)
}

func print(c int) {
	// The value of c was copied.
	// So 'c' here is not the same as 'c' in the for loop above.
	// It's a "coincidence" that they are both named c
	// (it's irrelevant).
	fmt.Println("c is:", c)
}


        </pre></code></figure>



        <h2>Fix 2</h2>
        <p>
            But let's say you wanted to keep the anonymous function? They can certanly be useful, creating a named function that is only used in one place is kind of ugly.
            This code fixes this by explicitly copying the variable before using it in the anonymous function. This works because each run (itteration) through the loop now gets its own variable, with its own value.
            So it does not matter when the go routine actualy runs. It will refer to its own variable 'dd' that never changes.
        </p>


        <figure class="file"><figcaption><a href="https://play.golang.org/p/MDg7Pl0-E4">https://play.golang.org/p/MDg7Pl0-E4</a></figcaption><code><pre>

package main

import (
	"fmt"
	"time"
)

func main() {

	// Fix 2
	fmt.Println("Fix 2 for Example B")
	for d := 0; d < 3; d++ {
		// The value of d is copied into its own variable. 
		// This happens for every iteraion in the loop.
		dd := d
		go func() {
			fmt.Println("dd is:", dd)
		}()
	}

	time.Sleep(2 * time.Second)

}
        </pre></code></figure>

        <h2>Foo</h2>


        <figure class="file"><figcaption><a href="https://play.golang.org/p/QO506H3qTz">https://play.golang.org/p/QO506H3qTz</a></figcaption><code><pre>

package main

import (
	"fmt"
	"time"
)

func main() {

	// Fix 3
	fmt.Println("Fix 3 for Example B")
	for e := 0; e < 3; e++ {
		go func(ee int) {
			// The value of e is copied into its own variable ee
			// (We could also call this new varaible e)
			fmt.Println("ee is:", ee)
		}(e) // e becomes ee inside the function
	}

	time.Sleep(2 * time.Second)

}
        </pre></code></figure>




        <h1>Links</h1>
        <h2>Closures in Go</h2>
        <p>
            <ul style="padding-left: 20px;"> <!-- FIXME TODO -->
                <li><a href="https://gobyexample.com/closures">https://gobyexample.com/closures</a></li>
                <li><a href="https://tour.golang.org/moretypes/25">https://tour.golang.org/moretypes/25</a></li>
            </ul>
        </p>






    </article>

